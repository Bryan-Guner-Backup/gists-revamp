function requestA() {
   var p = promise;
   // make some request remotely
   // when it finishes, call p.fulfill(requestA_value);
   // if it errors, call p.fail();

   p.defer(); // signal this function as deferred completion
}

function requestB() {
   var p = promise;
   // make some request remotely
   // when it finishes, call p.fulfill(requestA_value);
   // if it errors, call p.fail();

   p.defer(); // signal this function as deferred completion
}



--------------------------
// intersection (serial):

function intersection(A, B) {
   function get_result() { return promise.messages[0]; }

   var p = promise, resultA, resultB, result;
   A() @ (resultA = get_result()) @ B() @ (resultB = get_result()) @ (function(){
      result = resultA + resultB;
      console.log(result);
      p.fulfill(result);
   });
   p.defer();
}

intersection(requestA, requestB) @ function(){
   console.log("Intersection: "+promise.messages[0]);
};



--------------------------
// intersection (parallel):

function intersection(A, B) {
   function complete() {
      var p = promise, result;
      results.push(p.messages[0]);

      if (results.length == 2) {
         result = results[0] + results[1];
         console.log(result);
         p.fulfill(result);
      }
   }

   var p = promise,
       results = array()
   ;

   // here, A() and B() will run in parallel, and `complete` will be the gate
   A() @ complete();
   B() @ complete();

   p.defer();
}

intersection(requestA, requestB) @ function(){
   console.log("Intersection: "+promise.messages[0]);
};